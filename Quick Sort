퀵 정렬

대표적인 분할 정복 알고리즘
특정한 값을 기준으로 큰 수와 작은 수로 나눔
기준 값 = 피벗(Pivot)

일반적으로 가장 맨앞에 있는 값을 피벗값으로 설정

3 7 8 1 5 9 6 10 2 4
기준 값 3을 선택한 뒤 왼쪽에서 오른쪽으로 이동하면서 3보다 큰 값을 선택(7)
기준 값 3에서 오른쪽에서 왼쪽으로 이동하면서 3보다 작은 값을 선택(2)
이제 큰 값과 작은 값을 변경
3 2 8 1 5 9 6 10 7 4
3 2 1 8 5 9 6 10 7 4
8과 1이 엇갈렸을 시 왼쪽에 있는 더 작은 값(1)과 기준 값(3)이랑 변경
1 2 3 8 5 9 6 10 7 4 (3은 정렬된 상태)
3을 기준으로 왼쪽과 오른쪽으로 나눈후 각자 피벗 값을 선택해서 반복(왼쪽 : 1 / 오른쪽 : 8)

퀵 정렬은
= O(n * log2n)
= O(nlogn)

최악의 시간 복잡도는(이미 정렬이 되어있을 때 )
O(n^2)

대수학에서는 log는 밑이 10인 수지만 알고리즘에서는 밑이 2인것 같다.(통상적인 Big-O 시간 복잡도 표기법에서는 로그의 밑과 상관없이 로그라고 쓰는 것)

재귀함수를 사용해서

#include <stdio.h>

int data[10] = { 1,10,5,8,7,6,4,3,2,9 };
int number = 10;

void quickSort(int *data, int start, int end)
{
    if (start >= end) { // 원소가 1개인 경우
        return; 
    }
    int key = start; //키는 첫번째 원소
    int i = start + 1; //큰값 찾을때의 인덱스
    int j = end; // 오른쪽 출발 지점
    int temp;

    while (i <= j) // 엇갈릴 때까지 반복
    {
        while (i <= end && data[i] <= data[key]) //키 값보다 큰 값 만날때 까지
            i++;
        while (data[j] >= data[key] && j > start) //키 값보다 작은 값 만날때 까지
            j--;

        if (i > j)
        {
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        }
        else
        {
            temp = data[j];
            data[j] = data[i];
            data[i] = temp;
        }        
    }
    quickSort(data, start, j - 1);
    quickSort(data, j + 1, end);
}

int main(void) {   

    quickSort(data, 0, number - 1);
    for (int i = 0; i < number; i++)
        printf("%d ", data[i]);

    return 0;
}
